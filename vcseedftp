#!/usr/bin/env python
#encoding: utf8

##@namespace vcseedftp
# 軟體執行檔
# 
# 這個檔案是軟體執行檔，同時也包括主要的函式庫跟實作
# 
# @author	Chun-Yu Lee (Mat) <matlinuxer2@gmail.com> 
# @author	Dieter Hsu <dieterplex@gmail.com>
# @date		2012-2013
# @copyright	Chun-Yu Lee || Dieter Hsu 
#

import os
import sys
import subprocess
import tempfile

try:
	import ConfigParser
except ImportError:
	import configparser as ConfigParser


SELF = os.path.realpath( __file__ )
ROOT = os.path.dirname( SELF )

HOST     = ""
USER     = "" 
PASS     = "" 
LCD      = "" 
RCD      = "" 
EXCL     = []
FTP_PUSH = False
EXCLUDES = ""


## 檢查是否是 python3
#
# 檢查是否是 python3
#
def isPython3():
	major_version = sys.version_info[0]
	if major_version == 3:
		return True
	else:
		return False

## 執行系統指令
#
## 執行系統指令，並取得 stdout 跟 stderr 的結果
#
# @param cmd	指令的內容
# @retval tuple	回傳值為 ( retcode, out, err )
#
def popen(cmd):
	"""operations from LCD"""
	pipe = subprocess.Popen([ cmd ], shell=True, cwd=LCD, stdout = subprocess.PIPE, stderr = subprocess.PIPE )
	(out, err) = pipe.communicate()

	## for python3
	if type( out ) == type( b"bytes" ):
		out = str(out)

	## for python3
	if type( err ) == type( b"bytes" ):
		err = str(err)

	return pipe.wait(), out, err

def file2string(path):
	with open(path) as f:
		return f.read()

def string2file(string, path):
	with open(path, 'w') as f:
		f.write(string)

def do_ftp_download():
	script_file = tempfile.mktemp()
	script_stdout = script_file + ".log"
	script_stderr = script_file + ".err"

	script_tmpl = """
	debug 2
	set ftp:list-options -a;
	set ftp:ssl-allow no;
	set ftp:use-mdtm no
	open ftp://%s:%s@%s || exit; 
	lcd %s || exit;
	cd %s  || exit;
	mirror --delete --verbose --parallel=3 %s ;
	""" 
	
	script_txt = script_tmpl % ( USER, PASS, HOST, LCD, RCD, EXCLUDES )
	string2file( script_txt, script_file )

	cmd = "lftp -f %s" % ( script_file )
	proc = subprocess.Popen([ cmd ], shell=True, stdout=open( script_stdout, "w+"), stderr=open( script_stderr, "w+") )

	print(cmd)
	print(script_txt)

	retcode = proc.wait()

	cmd = "echo ==== %s ==== ; cat %s " % ( script_stdout, script_stdout )
	_, result, _ = popen(cmd)
	print( result )
	cmd = "echo ==== %s ==== ; cat %s | grep -v '^Mirroring' " % ( script_stderr, script_stderr )
	_, result, _ = popen(cmd)
	print( result )

	print("return code: ", retcode)
	os.unlink( script_file )
	os.unlink( script_stdout )
	os.unlink( script_stderr )

	return retcode

def do_vcs_goto_branch( br ):
	cmd = "git checkout %s " % ( br )  ## 不要用 --force ，如此會打亂 timestamp，而造成 lftp 重複 mirror
	retcode, out, err = popen(cmd)

	return retcode

def do_vcs_check():
	check1 = False
	check2 = False

	if os.access( LCD, os.R_OK | os.W_OK | os.X_OK ):
		check1 = True

	if os.access( os.path.join( LCD, ".git" ), os.R_OK | os.W_OK | os.X_OK ):
		check2 = True	

	if check1 and check2:
		return 0

	elif check1 != True:
		return 1
	elif check2 != True:
		return 2
	else:
		return 3
## 初始化 Git repository
# 
# @todo guard option for hook
#
def do_vcs_init():
	cmd = "git init; touch .gitignore; "
	cmd += "git add --all; "
	cmd += "git commit --author \"Version Control Seed for FTP <bot@vcseedftp>\" -m init; "
	cmd += "git branch for_merge master"
	popen(cmd)
	#do_enable_hook()

## 建立或移除 push2upload hook script
def do_enable_hook(enable=True):
	pathname = os.path.join(LCD, '.git', 'hooks', 'post-receive')
	if not enable and os.access( pathname, os.W_OK ):
		os.remove(pathname)
		return

	hook_content = """
#!/bin/sh
set -e
active_branch=$(git symbolic-ref HEAD)
read oldrev newrev branch
[ x"$branch" == x"refs/heads/for_merge" ] || exit 1
[ x"$branch" != x"$active_branch" ]       || exit 1
export GIT_DIR=$(cd ${GIT_DIR}; pwd)
export GIT_WORK_TREE="$(cd ${GIT_DIR}/..; pwd)"
vcseedftp_file='%s'
python <<EOF
import imp
x=imp.load_source('vcseedftp','$vcseedftp_file')
x.do_push2upload('$GIT_WORK_TREE','$oldrev','$newrev')
EOF
""" % SELF
	string2file(hook_content, pathname)
	# chmod u+x
	import stat
	st = os.stat(pathname)
	os.chmod(pathname, st.st_mode | stat.S_IEXEC)

def do_vcs_commit():
	cmd = "git add --all; "
	cmd += "git commit --author \"Version Control Seed for FTP <bot@vcseedftp>\" -m \"*\" "
	popen(cmd)

def check_vcs_mergefailed( lcd, hash_for_merge ):

	cmd = "cat ~/.vcseedftp-mergefail.log | grep \"%s\t%s\" " % ( lcd, hash_for_merge )
	retcode, out, err = popen(cmd)
	if retcode == 0:
		hash_intersect = out.strip()
		return True
	else:
		return False

def get_hash_from_branch( br ):
	result = ""

	cmd = "git rev-list --max-count=1 '%s' | cut -c1-7 " % ( br )
	retcode, out, err = popen(cmd)
	if retcode == 0:
		result = out.strip()

	return result

def get_base_hash_from_branches( br1, br2 ):
	result = ""

	cmd = "git merge-base %s %s | cut -c1-7" % ( br1, br2 )
	retcode, out, err = popen(cmd)
	if retcode == 0:
		result = out.strip()

	return result

def get_merged_list():
	"""return hash and log of commits from last merge line by line
	"""
	hash_pre_formerge	= get_hash_from_branch( "for_merge^" )
	hash_pre_master 	= get_hash_from_branch( "master^" )
	hash_base 			= get_base_hash_from_branches(hash_pre_formerge, hash_pre_master)
	cmd = "git log --not --pretty='%h %s' for_merge..{0}".format(hash_base)
	_, result, _ = popen(cmd)
	return result

def check_vcs_incomming():

	hash_for_merge = "" # branch == "for_merge" 的 hash
	hash_intersect = "" # "for_merge" 跟 "master" 分支共同交集的 hash

	hash_for_merge = get_hash_from_branch( "for_merge" )
	hash_intersect = get_base_hash_from_branches( "master", "for_merge" )

	print ( ">>> for_merge = '%s', intersect='%s' " % (hash_for_merge, hash_intersect) ) 

	if hash_intersect != hash_for_merge and hash_for_merge != "" and hash_intersect != "":
		if check_vcs_mergefailed( LCD, hash_for_merge ):
			print ( ">>> Changeset %s of for_merge 曾經 merge failed, 跳過 merge" % (hash_for_merge) )
			return False
		else:
			return True
	else:
		if hash_intersect == hash_for_merge:
			print ( ">>> for_merge 的 HEAD 已在 master 的 changesets 裡，不需要再 merge " )
		return False

def do_vcs_reset():
	# get for_merge commit hash
	for_merge_hash = get_hash_from_branch( "for_merge" )
	cmd =  "git reset --hard;"
	#cmd += "git clean -df;" # 先不能執行 git clean, 不然 mirror --delete --reverse 會刪掉某些 untrack 的資料目錄
	cmd += "echo \"%s\t%s\" >> ~/.vcseedftp-mergefail.log" % (LCD, for_merge_hash)
	popen(cmd)

def do_vcs_merge():
	"""merge `for_merge' branch to master branch"""

	cmd = "git merge --ff-only for_merge"
	retcode, out, err = popen(cmd)
	if retcode != 0:
		print("Merge 失敗, 原因: %s" % err.strip())
		return False
	else:
		cmd = "git merge --abort"
		popen(cmd)
		return True

def do_ftp_upload():
	script_file = tempfile.mktemp()
	script_stdout = script_file + ".log"
	script_stderr = script_file + ".err"

	script_tmpl = """
	debug 2
	set ftp:list-options -a;
	set ftp:ssl-allow no;
	set ftp:use-mdtm no
	open ftp://%s:%s@%s || exit; 
	lcd %s || exit;
	cd %s  || exit;
	mirror --reverse --dry-run --delete --verbose=3 --parallel=3 %s ;
	""" 
	
	script_txt = script_tmpl % ( USER, PASS, HOST, LCD, RCD, EXCLUDES )
	string2file( script_txt, script_file )

	cmd = "lftp -f %s" % ( script_file )
	proc = subprocess.Popen([ cmd ], shell=True, stdout=open( script_stdout, "w+"), stderr=open( script_stderr, "w+") )

	print(cmd)
	print(script_txt)

	retcode = proc.wait()

	cmd = "echo ==== %s ==== ; cat %s " % ( script_stdout, script_stdout )
	_, result, _ = popen(cmd)
	print( result )
	cmd = "echo ==== %s ==== ; cat %s | grep -v '^Mirroring' " % ( script_stderr, script_stderr )
	_, result, _ = popen(cmd)
	print( result )

	print("return code: ", retcode)
	os.unlink( script_file )
	os.unlink( script_stdout )
	os.unlink( script_stderr )
	
	return retcode

## 將 git 的版本差異轉換成 lftp 的指令
#
# 將 git 在兩個 commit 之間的差異清單，轉換成 lftp 的指令
#
# @param diff_output	差異檔案清單的輸出內容 ( ex: git diff --name-status
# 
# @todo python3 的 Big5 中文檔名輸出結果跟 python2 不一致
#
def convert_diff_to_ftp_commands( diff_output ):
	result = []

	for line in diff_output.strip().split('\n'):
		tag      = line.split("\t")[0]
		filename = line.split("\t")[1]

		if filename[0] == "\"" and filename[-1:] == "\"":
			if isPython3():
				## @todo python3 的輸出結果跟 python2 不一樣，待解的懸案
				filename = bytes( filename[1:-1], 'utf-8').decode('unicode_escape') 
			else:
				filename = filename[1:-1].decode('string_escape')

		if tag == "A" or tag == "M":
			result.append( "mput -d '%s' " % ( filename ) ) # use mput to create leading directory smartly
		elif tag == "D" :
			result.append( "rm '%s' " % ( filename ) )
		else:
			result.append( "# unknow tag '%s' " % ( tag ) )

	output = "\n".join( result )
	
	return output

def do_ftp_upload2( old_rev, new_rev ):
	script_file = tempfile.mktemp()
	script_stdout = script_file + ".log"
	script_stderr = script_file + ".err"

	cmd =  "git diff --name-status %s %s" % ( old_rev, new_rev )
	retcode, out, err = popen(cmd)
	
	upload_commands_text = convert_diff_to_ftp_commands( out )

	script_tmpl = """
	debug 2
	set ftp:list-options -a;
	set ftp:ssl-allow no;
	set ftp:use-mdtm no
	open ftp://%s:%s@%s || exit; 
	lcd %s || exit;
	cd %s  || exit;
	""" 
	script_tmpl += upload_commands_text
	
	script_txt = script_tmpl % ( USER, PASS, HOST, LCD, RCD )
	string2file( script_txt, script_file )

	cmd = "lftp -f %s" % ( script_file )
	proc = subprocess.Popen([ cmd ], shell=True, stdout=open( script_stdout, "w+"), stderr=open( script_stderr, "w+") )

	print(cmd)
	print(script_txt)

	retcode = proc.wait()

	cmd = "echo ==== %s ==== ; cat %s " % ( script_stdout, script_stdout )
	_, result, _ = popen(cmd)
	print( result )
	cmd = "echo ==== %s ==== ; cat %s | grep -v '^Mirroring' " % ( script_stderr, script_stderr )
	_, result, _ = popen(cmd)
	print( result )

	print("return code: ", retcode)
	os.unlink( script_file )
	os.unlink( script_stdout )
	os.unlink( script_stderr )

	return retcode

def do_ftp_sync_check():
	result = -1

	script_file = tempfile.mktemp()
	script_stdout = script_file + ".log"
	script_stderr = script_file + ".err"

	script_tmpl = """
	debug 2
	set ftp:list-options -a;
	set ftp:ssl-allow no;
	set ftp:use-mdtm no
	open ftp://%s:%s@%s || exit; 
	lcd %s || exit;
	cd %s  || exit;
	mirror --no-perms --no-umask --dry-run    --delete --verbose --parallel=5 %s ;
	mirror --no-perms --no-umask --dry-run -R --delete --verbose --parallel=5 %s ;
	""" 
	
	script_txt = script_tmpl % ( USER, PASS, HOST, LCD, RCD, EXCLUDES, EXCLUDES )
	string2file( script_txt, script_file )

	cmd = "lftp -f %s" % ( script_file )
	proc = subprocess.Popen([ cmd ], shell=True, stdout=open( script_stdout, "w+"), stderr=open( script_stderr, "w+") )

	print(cmd)
	print(script_txt)

	retcode = proc.wait()

	print("return code: ", retcode)

	difference_complain = file2string( script_stdout )
	print( "difference_complain: ", difference_complain )

	if retcode == 0 and difference_complain == "":
		result = 0

	os.unlink( script_file )
	os.unlink( script_stdout )
	os.unlink( script_stderr )

	return result

## 更新即上傳
#
# 此功能由Server端Git repository hook呼叫時，
# 會呼叫 do_vcs_merge() merge 到 `master` branch，
# 並利用FTP上傳功能更新遠端檔案。
#
# @param work_tree Git repository 工作區路徑，尋找設定檔用
# @param oldrev push完成前 `for_merge` branch 的 commit hash
# @param newrev push完成後 `for_merge` branch 的 commit hash
# @retval 回傳integer作為hook script的回傳值
#
# NOT TEST YET
def do_push2upload(work_tree, oldrev, newrev):
	def get_ini_pathname():
		cmd = "/bin/grep -l '^LCD.*=.*%s' %s" % (work_tree, ROOT)
		pipe = subprocess.Popen([cmd], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		out, err = pipe.communicate()
		pipe.wait()
		return out, err

	settings_path, _ = get_ini_pathname()
	do_load_settings( settings_path )

	# check other lock
	import time
	repo_name = os.path.basename(work_tree)
	lock_suffix = '.vcseedftp.lock.%s' % repo_name
	cmd = "/bin/find /tmp -name '*%s'" % lock_suffix
	trylimit = 3
	while popen([cmd])[1] != "":		# found lock of this repo
		trylimit = trylimit - 1
		if trylimit < 1:
			return 2					# report busy
		time.sleep(10)

	# create lock
	lock_fd, lock = tempfile.mkstemp(suffix=lock_suffix, text=True)
	#string2file(" ".join([work_tree, oldrev, newrev]), lock)

	cmd = "test -f %s" % lock
	retcode, _, _ = popen([cmd])
	if retcode != 0:
		return 1

	# merge & upload
	main()

	# release lock
	if os.access(lock, os.W_OK):
		os.remove(lock)
	print('>>> ok!')
	return 0

## 設定載入
#
# 設定檔載入功能會依照順序檢查：
#
#   1. 執行目錄下的 `vcseedftp.ini`
#   2. stdin 的第一個參數
#   3. 函式引數 path
#
# 作為設定檔載入，沒有則結束程式
#
# @param path 指定使用的設定檔路徑
#
def do_load_settings(path=None):

	global HOST
	global USER
	global PASS
	global LCD
	global RCD
	global EXCL
	global FTP_PUSH
	global EXCLUDES
	config = None

	if sys.argv.__len__() == 1:
		# 預設是讀取專案目錄下的 vcseedftp.ini
		settings_file = os.path.join( ROOT, "vcseedftp.ini")
	elif sys.argv.__len__() == 2:
		# 若有指定 *.ini 檔，則用指定的設定檔
		settings_file = os.path.realpath( sys.argv[1] )
	elif path is not None:
		settings_file = os.path.realpath( path )
	else:
		settings_file = None

	if os.access( settings_file, os.R_OK ):
		config = ConfigParser.RawConfigParser()
		config.optionxform = str
		config.read(settings_file)
	else:
		print("設定檔無法讀取: ", settings_file)
		exit()

	HOST     = config.get('lftp', 'HOST')
	USER     = config.get('lftp', 'USER')
	PASS     = config.get('lftp', 'PASS')
	LCD      = config.get('lftp', 'LCD')
	RCD      = config.get('lftp', 'RCD')

	if config.has_option( 'lftp', 'EXCL' ):
		EXCL = config.get('lftp', 'EXCL').split('\n')

	EXCL += [
		"\.hg",
		"\.hgignore",
		"\.git",
		"\.gitignore",
		"error_log",
		"UploadFile/.*/",
		"templates/.*/templates_c/",
		]

	for i in range( 0, EXCL.__len__() ):
		val = EXCL[i].strip()
		if val != "":
			EXCL[i] = "--exclude "+EXCL[i]

	EXCLUDES = " ".join( EXCL )

	if config.has_section( 'vcseedftp' ) and config.has_option( 'vcseedftp', 'FTP_PUSH' ):
		ftp_push_str = config.get( 'vcseedftp', 'FTP_PUSH' ).strip().lower()
		if ftp_push_str == "yes" or ftp_push_str == "true" or ftp_push_str == "enable" or ftp_push_str == "on":
			FTP_PUSH = True

	print("FTP_PUSH : ", FTP_PUSH)
	print("HOST     : ", HOST)
	print("USER     : ", USER)
	print("PASS     : ", PASS)
	print("LCD      : ", LCD)
	print("RCD      : ", RCD)
	print("EXCL     : ", EXCL)

## 主程式
#
# 作為執行檔時會執行的主程式
# 需先 do_load_settings()
#
def main():
	ret = do_vcs_check()
	if ret == 1:
		print("本地端目錄存取有誤: ", LCD)
		exit()
	elif ret == 2:
		do_vcs_init()

	do_vcs_goto_branch( "master" )
	do_ftp_download()
	do_vcs_commit()

	if FTP_PUSH and check_vcs_incomming():
		old_rev = get_hash_from_branch( "master" )
		print ( "進行 merge ..." )
		ret = do_vcs_merge()
		if ret:	
			msg_patch_info = get_merged_list()
			print( "Merged patch List:\n%s" % msg_patch_info )
			print ( "Merge 成功，進行 ftp uploading ..." )
			#do_ftp_upload()
			new_rev = get_hash_from_branch( "master" )
			do_ftp_upload2( old_rev, new_rev )
			print ( "檢查 local 跟 remote ftp 的檔案是否一致" )
		
			ret = do_ftp_sync_check()
			if ret == 0:
				print ( ">>> ftp sync 狀態一致 <<<" )
			else:
				print ( "!!! local 跟 remote 檔案不一致 !!!" )
		else:
			print( "恢復資料中..." )
			do_vcs_reset()

if __name__ == "__main__":
	do_load_settings()
	main()
